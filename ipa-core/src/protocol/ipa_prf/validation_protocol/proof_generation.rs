use std::{array, iter::zip, ops::Mul};

use typenum::{Unsigned, U, U8};

use crate::{
    error::Error,
    ff::{Fp61BitPrime, Serializable},
    helpers::{Direction, MpcMessage, TotalRecords},
    protocol::{
        context::{
            dzkp_field::{UVTupleBlock, TABLE_LEFT, TABLE_RIGHT},
            dzkp_validator::MAX_PROOF_RECURSION,
            Context,
        },
        ipa_prf::{
            malicious_security::lagrange::{CanonicalLagrangeDenominator, LagrangeTable},
            CompressedProofGenerator, FirstProofGenerator,
        },
        prss::SharedRandomness,
        RecordId, RecordIdRange,
    },
    secret_sharing::SharedValue,
    utils::arraychunks::ArrayChunkIterator,
};

/// This a `ProofBatch` generated by a prover.
pub struct ProofBatch {
    pub first_proof: [Fp61BitPrime; FirstProofGenerator::PROOF_LENGTH],
    pub proofs: Vec<[Fp61BitPrime; CompressedProofGenerator::PROOF_LENGTH]>,
}

impl FromIterator<Fp61BitPrime> for ProofBatch {
    fn from_iter<T: IntoIterator<Item = Fp61BitPrime>>(iter: T) -> Self {
        let mut iterator = iter.into_iter();
        // consume the first P elements
        let first_proof = iterator
            .by_ref()
            .take(FirstProofGenerator::PROOF_LENGTH)
            .collect::<[Fp61BitPrime; FirstProofGenerator::PROOF_LENGTH]>();
        // consume the rest
        let proofs = iterator.collect::<Vec<[Fp61BitPrime; FirstProofGenerator::PROOF_LENGTH]>>();
        ProofBatch {
            first_proof,
            proofs,
        }
    }
}

impl ProofBatch {
    /// This function returns the length in field elements.
    #[allow(clippy::len_without_is_empty)]
    #[must_use]
    pub fn len(&self) -> usize {
        FirstProofGenerator::PROOF_LENGTH
            + self.proofs.len() * CompressedProofGenerator::PROOF_LENGTH
    }

    #[allow(clippy::unnecessary_box_returns)] // clippy bug? `Array` exceeds unnecessary-box-size
    fn to_array(&self) -> Box<Array> {
        assert!(self.len() <= ARRAY_LEN);
        let iter = self
            .first_proof
            .iter()
            .chain(self.proofs.iter().flat_map(|x| x.iter()));
        let mut array = Box::new(array::from_fn(|_| Fp61BitPrime::ZERO));
        for (i, v) in iter.enumerate() {
            array[i] = *v;
        }
        array
    }

    /// Each helper party generates a set of proofs, which are secret-shared.
    /// The "left" shares of these proofs are for the helper on the left.
    /// The "right" shares of these proofs need not be transmitted over the wire, as they
    /// are generated via `PRSS`, so the helper on the right can independently generate them.
    /// The final proof must be "masked" with random values drawn from PRSS.
    /// These values will be needed at verification time.
    /// The function outputs `my_proofs_left_shares`, `shares_of_proofs_from_prover_left`,
    /// `p_mask_from_right_prover`, `q_mask_from_left_prover`
    ///
    /// ## Panics
    /// Panics when the function fails to set the masks without overwritting `u` and `v` values.
    /// This only happens when there is an issue in the recursion.
    pub fn generate<C>(
        ctx: &C,
        mut prss_record_ids: RecordIdRange,
        table_index_tuple_inputs: impl Iterator<Item = (u8, u8)>,
        uv_tuple_inputs: impl Iterator<Item = UVTupleBlock<Fp61BitPrime>>,
    ) -> (Self, Self, Fp61BitPrime, Fp61BitPrime)
    where
        C: Context,
    {
        const FRF: usize = FirstProofGenerator::RECURSION_FACTOR;
        const FLL: usize = FirstProofGenerator::LAGRANGE_LENGTH;
        const FPL: usize = FirstProofGenerator::PROOF_LENGTH;
        const CRF: usize = CompressedProofGenerator::RECURSION_FACTOR;
        const CLL: usize = CompressedProofGenerator::LAGRANGE_LENGTH;
        const CPL: usize = CompressedProofGenerator::PROOF_LENGTH;

        // precomputation for first proof
        let first_denominator = CanonicalLagrangeDenominator::<Fp61BitPrime, FRF>::new();
        let first_lagrange_table = LagrangeTable::<Fp61BitPrime, FRF, FLL>::from(first_denominator);

        let table_left_0: [[Fp61BitPrime; FPL]; 8] = array::from_fn(|i| {
            let mut result = [Fp61BitPrime::ZERO; FPL];
            let u = &TABLE_LEFT[i];
            result[0..4].copy_from_slice(u);
            let (a, b) = result.split_at_mut(8);
            b.copy_from_slice(&first_lagrange_table.eval(<&[_; 8]>::try_from(&*a).unwrap()));
            result
        });
        let table_left_1: [[Fp61BitPrime; FPL]; 8] = array::from_fn(|i| {
            let mut result = [Fp61BitPrime::ZERO; FPL];
            let u = &TABLE_LEFT[i];
            result[4..8].copy_from_slice(u);
            let (a, b) = result.split_at_mut(8);
            b.copy_from_slice(&first_lagrange_table.eval(<&[_; 8]>::try_from(&*a).unwrap()));
            result
        });
        let table_right_0: [[Fp61BitPrime; FPL]; 8] = array::from_fn(|i| {
            let mut result = [Fp61BitPrime::ZERO; FPL];
            let v = &TABLE_RIGHT[i];
            result[0..4].copy_from_slice(v);
            let (a, b) = result.split_at_mut(8);
            b.copy_from_slice(&first_lagrange_table.eval(<&[_; 8]>::try_from(&*a).unwrap()));
            result
        });
        let table_right_1: [[Fp61BitPrime; FPL]; 8] = array::from_fn(|i| {
            let mut result = [Fp61BitPrime::ZERO; FPL];
            let v = &TABLE_RIGHT[i];
            result[4..8].copy_from_slice(v);
            let (a, b) = result.split_at_mut(8);
            b.copy_from_slice(&first_lagrange_table.eval(<&[_; 8]>::try_from(&*a).unwrap()));
            result
        });

        let first_proof = FirstProofGenerator::compute_proof(table_index_tuple_inputs.chunk_array::<2>().map(
            |chunk| {
                let [(u0, v0), (u1, v1)] = chunk;
                [
                    (
                        table_right_0[usize::from(u0)],
                        table_left_0[usize::from(v0)],
                    ),
                    (
                        table_right_1[usize::from(u1)],
                        table_left_1[usize::from(v1)],
                    ),
                ]
            },
        )
        .flatten());

        // generate first proof from input iterator
        let (mut uv_values, first_proof_from_left, my_first_proof_left_share) =
            FirstProofGenerator::gen_artefacts_from_recursive_step(
                ctx,
                &mut prss_record_ids,
                first_proof,
                uv_tuple_inputs,
            );

        // `MAX_PROOF_RECURSION - 2` because:
        //  * The first level of recursion has already happened.
        //  * We need (CRF - 1) at the last level to have room for the masks.
        let max_uv_values: usize =
            (CRF - 1) * CRF.pow(u32::try_from(MAX_PROOF_RECURSION - 2).unwrap());
        assert!(
            uv_values.len() <= max_uv_values,
            "Proof batch is too large: have {} uv_values, max is {}",
            uv_values.len(),
            max_uv_values,
        );

        // storage for other proofs
        let mut my_proofs_left_shares =
            Vec::<[Fp61BitPrime; CPL]>::with_capacity(MAX_PROOF_RECURSION - 1);
        let mut shares_of_proofs_from_prover_left =
            Vec::<[Fp61BitPrime; CPL]>::with_capacity(MAX_PROOF_RECURSION - 1);

        // generate masks
        // Prover `P_i` and verifier `P_{i-1}` both compute p(x)
        // therefore the "right" share computed by this verifier corresponds to that which
        // was used by the prover to the right.
        let (my_p_mask, p_mask_from_right_prover) =
            ctx.prss().generate_fields(prss_record_ids.expect_next());
        // Prover `P_i` and verifier `P_{i+1}` both compute q(x)
        // therefore the "left" share computed by this verifier corresponds to that which
        // was used by the prover to the left.
        let (q_mask_from_left_prover, my_q_mask) =
            ctx.prss().generate_fields(prss_record_ids.expect_next());

        let denominator = CanonicalLagrangeDenominator::<Fp61BitPrime, CRF>::new();
        let lagrange_table = LagrangeTable::<Fp61BitPrime, CRF, CLL>::from(denominator);

        // The last recursion can only include (Î» - 1) u/v value pairs, because it needs to put the
        // masks in the constant term. If we compress to `uv_values.len() == CRF`, then we need to
        // do two more iterations: compressing CRF u/v values to 1 pair of (unmasked) u/v values,
        // and then compressing that pair and the masks to the final u/v value.
        //
        // There is a test for this corner case in validation.rs.
        let mut did_set_masks = false;

        // recursively generate proofs via CompressedProofGenerator
        while !did_set_masks {
            if uv_values.len() < CRF {
                did_set_masks = true;
                uv_values.set_masks(my_p_mask, my_q_mask).unwrap();
            }
            let my_proof =
                CompressedProofGenerator::compute_proof_from_uv(uv_values.iter(), &lagrange_table);
            let (uv_values_new, share_of_proof_from_prover_left, my_proof_left_share) =
                CompressedProofGenerator::gen_artefacts_from_recursive_step(
                    ctx,
                    &mut prss_record_ids,
                    my_proof,
                    uv_values.iter(),
                );
            shares_of_proofs_from_prover_left.push(share_of_proof_from_prover_left);
            my_proofs_left_shares.push(my_proof_left_share);

            uv_values = uv_values_new;
        }

        let my_batch_left_shares = ProofBatch {
            first_proof: my_first_proof_left_share,
            proofs: my_proofs_left_shares,
        };
        let shares_of_batch_from_left_prover = ProofBatch {
            first_proof: first_proof_from_left,
            proofs: shares_of_proofs_from_prover_left,
        };
        (
            my_batch_left_shares,
            shares_of_batch_from_left_prover,
            p_mask_from_right_prover,
            q_mask_from_left_prover,
        )
    }

    /// This function sends a `Proof` to the party on the left
    ///
    /// ## Errors
    /// Propagates error from sending values over the network channel.
    pub async fn send_to_left<C>(&self, ctx: &C, record_id: RecordId) -> Result<(), Error>
    where
        C: Context,
    {
        Ok(ctx
            .set_total_records(TotalRecords::Indeterminate)
            .send_channel::<Box<Array>>(ctx.role().peer(Direction::Left))
            .send(record_id, self.to_array())
            .await?)
    }

    /// This function receives a `Proof` from the party on the right.
    ///
    /// ## Errors
    /// Propagates errors from receiving values over the network channel.
    ///
    /// ## Panics
    /// If the recursion depth implied by `length` exceeds `MAX_PROOF_RECURSION`.
    pub async fn receive_from_right<C>(
        ctx: &C,
        record_id: RecordId,
        length: usize,
    ) -> Result<Self, Error>
    where
        C: Context,
    {
        assert!(length <= ARRAY_LEN);
        Ok(ctx
            .set_total_records(TotalRecords::Indeterminate)
            .recv_channel::<Box<Array>>(ctx.role().peer(Direction::Right))
            .receive(record_id)
            .await?
            .into_iter()
            .take(length)
            .collect())
    }
}

const ARRAY_LEN: usize = FirstProofGenerator::PROOF_LENGTH
    + (MAX_PROOF_RECURSION - 1) * CompressedProofGenerator::PROOF_LENGTH;
type Array = [Fp61BitPrime; ARRAY_LEN];

impl Serializable for Box<Array> {
    type Size = <U<ARRAY_LEN> as Mul<U8>>::Output;

    type DeserializationError = <Fp61BitPrime as Serializable>::DeserializationError;

    fn serialize(&self, buf: &mut generic_array::GenericArray<u8, Self::Size>) {
        for (hash, buf) in zip(
            **self,
            buf.chunks_mut(<<Fp61BitPrime as Serializable>::Size as Unsigned>::to_usize()),
        ) {
            hash.serialize(buf.try_into().unwrap());
        }
    }

    fn deserialize(
        buf: &generic_array::GenericArray<u8, Self::Size>,
    ) -> Result<Self, Self::DeserializationError> {
        Ok(buf
            .chunks(<<Fp61BitPrime as Serializable>::Size as Unsigned>::to_usize())
            .map(|buf| Fp61BitPrime::deserialize(buf.try_into().unwrap()))
            .collect::<Result<Vec<_>, _>>()?
            .try_into()
            .unwrap())
    }
}

impl MpcMessage for Box<Array> {}

/*
#[cfg(all(test, unit_test))]
mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::{Fp61BitPrime, U128Conversions},
        protocol::{
            context::Context,
            ipa_prf::{validation_protocol::{
                proof_generation::ProofBatch,
                validation::{/*test::simple_proof_check,*/ BatchToVerify},
            }, BLOCK_SIZE},
            RecordId, RecordIdRange,
        },
        secret_sharing::replicated::ReplicatedSecretSharing,
        test_executor::run,
        test_fixture::{Runner, TestWorld},
    };

    #[test]
    fn generate_verifier_batch() {
        run(|| async move {
            let world = TestWorld::default();

            let mut rng = thread_rng();

            // each helper samples a random value h
            // which is later used to generate distinct values across helpers
            let h = Fp61BitPrime::truncate_from(rng.gen_range(0u128..100));

            let result = world
                .semi_honest(h, |ctx, h| async move {
                    let h = Fp61BitPrime::truncate_from(h.left().as_u128() % 100);
                    // generate blocks of UV values
                    // generate u values as (1h,2h,3h,....,10h*BlockSize) split into Blocksize chunks
                    // where BlockSize = 32
                    // v values are identical to u
                    let uv_tuple_vec = (0usize..100)
                        .map(|i| {
                            (
                                (BLOCK_SIZE * i..BLOCK_SIZE * (i + 1))
                                    .map(|j| {
                                        Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h
                                    })
                                    .collect::<[Fp61BitPrime; BLOCK_SIZE]>(),
                                (BLOCK_SIZE * i..BLOCK_SIZE * (i + 1))
                                    .map(|j| {
                                        Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h
                                    })
                                    .collect::<[Fp61BitPrime; BLOCK_SIZE]>(),
                            )
                        })
                        .collect::<Vec<_>>();

                    // generate and output VerifierBatch together with h value
                    let (
                        my_batch_left_shares,
                        shares_of_batch_from_left_prover,
                        p_mask_from_right_prover,
                        q_mask_from_left_prover,
                    ) = ProofBatch::generate(
                        &ctx.narrow("generate_batch"),
                        RecordIdRange::ALL,
                        uv_tuple_vec.into_iter(),
                    );

                    let batch_to_verify = BatchToVerify::generate_batch_to_verify(
                        ctx.narrow("generate_batch"),
                        RecordId::FIRST,
                        my_batch_left_shares,
                        shares_of_batch_from_left_prover,
                        p_mask_from_right_prover,
                        q_mask_from_left_prover,
                    )
                    .await;

                    // generate and output VerifierBatch together with h value
                    (h, batch_to_verify)
                })
                .await;

            // proof from first party
            simple_proof_check(result[0].0, &result[2].1, &result[1].1);

            // proof from second party
            simple_proof_check(result[1].0, &result[0].1, &result[2].1);

            // proof from third party
            simple_proof_check(result[2].0, &result[1].1, &result[0].1);
        });
    }
}
*/
