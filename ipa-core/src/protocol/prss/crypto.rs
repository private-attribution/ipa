use aes::{
    cipher::{BlockEncrypt, KeyInit},
    Aes256,
};
use generic_array::{ArrayLength, GenericArray};
use hkdf::Hkdf;
use rand::{CryptoRng, RngCore};
use sha2::Sha256;
use typenum::U1;
use x25519_dalek::{EphemeralSecret, PublicKey};

use crate::{
    ff::Field,
    helpers::Direction,
    protocol::prss::{PrssIndex, PrssIndex128},
    secret_sharing::{
        replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
        SharedValue,
    },
};

/// Trait for random generation from random u128s.
///
/// It was previously assumed that our fields were of order << 2^128, in which case
/// `Field::truncate_from` can be used for this purpose. This trait makes the contract explicit.
pub trait FromRandomU128 {
    /// Generate a random value of `Self` from a uniformly-distributed random u128.
    fn from_random_u128(src: u128) -> Self;
}

impl FromRandomU128 for u128 {
    fn from_random_u128(src: u128) -> Self {
        src
    }
}

/// Trait for random generation.
///
/// The exact semantics of the generation depend on the value being generated, but like
/// `rand::distributions::Standard`, a uniform distribution is typical. When implementing
/// this trait, consider the consequences if the implementation were to be used in
/// an unexpected way. For example, an implementation that draws from a subset of the
/// possible values could be dangerous, if used in an unexpected context where
/// security relies on sampling from the full space.
pub trait FromRandom: Sized {
    type SourceLength: ArrayLength;

    /// Generate a random value of `Self` from `SourceLength` uniformly-distributed u128s.
    fn from_random(src: GenericArray<u128, Self::SourceLength>) -> Self;
}

impl<T: FromRandomU128> FromRandom for T {
    type SourceLength = U1;

    fn from_random(src: GenericArray<u128, U1>) -> Self {
        Self::from_random_u128(src[0])
    }
}

/// Trait for things that can be generated by PRSS.
///
/// We support two kinds of PRSS generation:
///  1. Raw values: In this case, two values are generated, one using the randomness that is shared
///     with the left helper, and one with the randomness that is shared with the right helper.
///     Thus, one of the generated values is known to both us and the left helper, and likewise for
///     the right helper.
///  2. Secret sharings: In this case, a single secret-shared random value is generated. The value
///     returned by `FromPrss` is our share of that sharing. Within `FromPrss`, the randomness shared
///     with the left and right helpers is used to construct the sharing.
///
/// In the first case, `FromPrss` is implemented for a tuple type, while in the second case,
/// `FromPrss` is implemented for a secret-shared type.
pub trait FromPrss<Params = ()>
where
    Self: Sized,
    Params: Default,
{
    fn from_prss_with<P: SharedRandomness + ?Sized, I: Into<PrssIndex>>(
        prss: &P,
        index: I,
        params: Params,
    ) -> Self;

    fn from_prss<P: SharedRandomness + ?Sized, I: Into<PrssIndex>>(prss: &P, index: I) -> Self {
        Self::from_prss_with(prss, index, Default::default())
    }
}

/// Generate two random values, one that is known to the left helper
/// and one that is known to the right helper.
impl<T: FromRandom> FromPrss for (T, T) {
    fn from_prss_with<P: SharedRandomness + ?Sized, I: Into<PrssIndex>>(
        prss: &P,
        index: I,
        _params: (),
    ) -> (T, T) {
        let (l, r) = prss.generate_arrays(index);
        (T::from_random(l), T::from_random(r))
    }
}

/// Generate a replicated secret sharing of a random value, which none
/// of the helpers knows. This is an implementation of the functionality 2.1 `F_rand`
/// described on page 5 of the paper:
/// "Efficient Bit-Decomposition and Modulus Conversion Protocols with an Honest Majority"
/// by Ryo Kikuchi, Dai Ikarashi, Takahiro Matsuda, Koki Hamada, and Koji Chida
/// <https://eprint.iacr.org/2018/387.pdf>
impl<T: FromRandom + SharedValue> FromPrss for AdditiveShare<T> {
    fn from_prss_with<P: SharedRandomness + ?Sized, I: Into<PrssIndex>>(
        prss: &P,
        index: I,
        _params: (),
    ) -> AdditiveShare<T> {
        let (l, r) = <(T, T) as FromPrss>::from_prss(prss, index);
        AdditiveShare::new(l, r)
    }
}

/// Generate a replicated secret sharing of a random value, which none
/// of the helpers knows. This is an implementation of the functionality 2.1 `F_rand`
/// described on page 5 of the paper:
/// "Efficient Bit-Decomposition and Modulus Conversion Protocols with an Honest Majority"
/// by Ryo Kikuchi, Dai Ikarashi, Takahiro Matsuda, Koki Hamada, and Koji Chida
/// <https://eprint.iacr.org/2018/387.pdf>
impl<T: FromRandom + SharedValue> FromPrss<usize> for AdditiveShare<T> {
    fn from_prss_with<P: SharedRandomness + ?Sized, I: Into<PrssIndex>>(
        prss: &P,
        index: I,
        len: usize,
    ) -> AdditiveShare<T> {
        assert_eq!(
            u32::try_from(len).unwrap(),
            <T as SharedValue>::BITS,
            "incorrect length {len} for AdditiveShare::FromPrss, expected {}",
            <T as SharedValue>::BITS,
        );
        let (l, r) = <(T, T) as FromPrss>::from_prss(prss, index);
        AdditiveShare::new(l, r)
    }
}

pub trait SharedRandomness {
    type ChunkIter<'a, Z: ArrayLength>: Iterator<Item = GenericArray<u128, Z>>
    where
        Self: 'a;

    /// Return an iterator over chunks of generated randomness.
    ///
    /// The iterator returns `GenericArray<u128, Z>` chunks known to the helper
    /// specified in `direction` parameter.
    ///
    /// This functionality is intended for use generating large vectorized values.
    #[must_use]
    fn generate_chunks_one_side<I: Into<PrssIndex>, Z: ArrayLength>(
        &self,
        index: I,
        direction: Direction,
    ) -> Self::ChunkIter<'_, Z>;

    /// Same as [`Self::generate_chunks_one_side`], but returns 2-tuples
    /// of `GenericArray<u128, Z>` chunks, one that is known to the
    /// left helper and one that is known to the right helper.
    ///
    /// This functionality is intended for use generating large vectorized values.
    #[must_use]
    fn generate_chunks_iter<I: Into<PrssIndex>, Z: ArrayLength>(
        &self,
        index: I,
    ) -> impl Iterator<Item = (GenericArray<u128, Z>, GenericArray<u128, Z>)>;

    /// Generate two random values, one that is known to the left helper
    /// and one that is known to the right helper.
    #[must_use]
    fn generate_arrays<I: Into<PrssIndex>, N: ArrayLength>(
        &self,
        index: I,
    ) -> (GenericArray<u128, N>, GenericArray<u128, N>) {
        Self::generate_chunks_iter(self, index).next().unwrap()
    }

    /// Generate two random values, one that is known to the left helper
    /// and one that is known to the right helper.
    #[must_use]
    fn generate_values<I: Into<PrssIndex>>(&self, index: I) -> (u128, u128) {
        let (l, r) = self.generate_arrays::<_, U1>(index);
        (l[0], r[0])
    }

    /// Generate two random field values, one that is known to the left helper
    /// and one that is known to the right helper.
    ///
    /// This alias is provided for compatibility with existing code. New code can just use
    /// `generate`.
    #[must_use]
    fn generate_fields<F: Field, I: Into<PrssIndex>>(&self, index: I) -> (F, F) {
        self.generate(index)
    }

    /// Generate something that implements the `FromPrss` trait.
    ///
    /// Generation by `FromPrss` is described in more detail in the `FromPrss` documentation.
    #[must_use]
    fn generate<T: FromPrss, I: Into<PrssIndex>>(&self, index: I) -> T {
        T::from_prss(self, index)
    }

    /// Generate some value that can be sampled from PRSS shared with the helper
    /// specified via `direction` argument. This may be convenient and more efficient,
    /// in cases when only value shared with one helper is required.
    ///
    /// Functionally, it is equivalent to calling [`Self::generate`] and dropping either
    /// left or the right variable. Performance-wise, this method should be preferred
    /// to use because it will do 50% of the work compared to regular [`Self::generate`].
    #[must_use]
    fn generate_one_side<T: FromRandom, I: Into<PrssIndex>>(
        &self,
        index: I,
        direction: Direction,
    ) -> T {
        let index = index.into();
        T::from_random(
            self.generate_chunks_one_side(index, direction)
                .next()
                .unwrap_or_else(|| panic!("Can't generate randomness for index {index:?}")),
        )
    }

    /// Generate something that implements the `FromPrss` trait, passing parameters.
    ///
    /// Generation by `FromPrss` is described in more detail in the `FromPrss` documentation.
    #[must_use]
    fn generate_with<T: FromPrss<P>, I: Into<PrssIndex>, P: Default>(
        &self,
        index: I,
        params: P,
    ) -> T {
        T::from_prss_with(self, index, params)
    }

    /// Generate a non-replicated additive secret sharing of zero.
    ///
    /// This is used for the MAC accumulators for malicious security.
    //
    // Equivalent functionality could be obtained by defining an `Unreplicated<F>` type that
    // implements `FromPrss`.
    #[must_use]
    fn zero<V: SharedValue + FromRandom, I: Into<PrssIndex>>(&self, index: I) -> V {
        let (l, r): (V, V) = self.generate(index);
        l - r
    }
}

// The key exchange component of a participant.
pub struct KeyExchange {
    sk: EphemeralSecret,
}

impl KeyExchange {
    pub fn new<R: RngCore + CryptoRng>(r: &mut R) -> Self {
        Self {
            sk: EphemeralSecret::random_from_rng(r),
        }
    }

    #[must_use]
    pub fn public_key(&self) -> PublicKey {
        PublicKey::from(&self.sk)
    }

    #[must_use]
    pub fn key_exchange(self, pk: &PublicKey) -> GeneratorFactory {
        debug_assert_ne!(pk, &self.public_key(), "self key exchange detected");
        let secret = self.sk.diffie_hellman(pk);
        let kdf = Hkdf::<Sha256>::new(None, secret.as_bytes());
        GeneratorFactory { kdf }
    }
}

/// This intermediate object exists so that multiple generators can be constructed,
/// with each one dedicated to one purpose.
pub struct GeneratorFactory {
    kdf: Hkdf<Sha256>,
}

impl GeneratorFactory {
    /// Create a new generator using the provided context string.
    #[allow(clippy::missing_panics_doc)] // Panic should be impossible.
    #[must_use]
    pub fn generator(&self, context: &[u8]) -> Generator {
        let mut k = aes::cipher::generic_array::GenericArray::default();
        self.kdf.expand(context, &mut k).unwrap();
        Generator {
            cipher: Aes256::new(&k),
            #[cfg(debug_assertions)]
            used: UsedSet::new(context.to_vec()),
        }
    }
}

/// The basic generator.  This generates values based on an arbitrary index.
#[derive(Debug)]
pub struct Generator {
    cipher: Aes256,
    #[cfg(debug_assertions)]
    used: UsedSet,
}

impl Generator {
    /// Generate the value at the given index.
    /// This uses the MMO^{\pi} function described in <https://eprint.iacr.org/2019/074>.
    #[must_use]
    pub(super) fn generate<I: Into<PrssIndex128>>(&self, index: I) -> u128 {
        let index = index.into();
        #[cfg(debug_assertions)]
        self.used.use_index(index).unwrap();
        let index = u128::from(index);

        let mut buf = index.to_le_bytes();
        self.cipher
            .encrypt_block(aes::cipher::generic_array::GenericArray::from_mut_slice(
                &mut buf,
            ));

        u128::from_le_bytes(buf) ^ index
    }
}

/// Keeps track of all indices used to generate shared randomness inside [`Generator`].
/// Any two indices provided to [`Generator::generate`] must be unique. This essentially
/// enforces there is always unique IV used per generator.
#[cfg(debug_assertions)]
#[derive(Default, Debug)]
struct UsedSet {
    key: String,
    used: crate::sync::Mutex<std::collections::HashSet<PrssIndex128>>,
}

#[cfg(debug_assertions)]
impl UsedSet {
    pub fn new(key: Vec<u8>) -> Self {
        use std::collections::HashSet;

        use crate::sync::{Arc, Mutex};

        Self {
            key: String::from_utf8(key).unwrap_or_else(|e| {
                panic!("PRSS key is not a valid UTF8 string: {}", e.utf8_error())
            }),
            used: Mutex::new(HashSet::default()),
        }
    }

    pub fn use_index(&self, index: PrssIndex128) -> Result<(), String> {
        if self.used.lock().unwrap().insert(index) {
            Ok(())
        } else {
            Err(format!(
                "Generated randomness for index '{index}' twice using the same key '{}'",
                self.key
            ))
        }
    }
}

#[cfg(all(test, unit_test))]
mod tests {
    #[test]
    #[cfg(debug_assertions)]
    #[should_panic(
        expected = "Generated randomness for index '0:0' twice using the same key 'foo'"
    )]
    fn rejects_the_same_index() {
        use rand::thread_rng;
        use crate::protocol::prss::KeyExchange;
        let other_gen = KeyExchange::new(&mut thread_rng());
        let gen = KeyExchange::new(&mut thread_rng())
            .key_exchange(&other_gen.public_key())
            .generator("foo".as_bytes());

        let _ = gen.generate(0);
        let _ = gen.generate(0);
    }
}
